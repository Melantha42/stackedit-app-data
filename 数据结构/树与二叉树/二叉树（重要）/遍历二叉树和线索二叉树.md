

# 遍历二叉树（Traversing binary tree）
遍历二叉树是按某条搜索路径巡访树中每个结点，每个结点均被访问且仅访问**一次**

我们经常希望访问树中的每一个结点并且查看它的值。有很多常见的顺序来访问所有的结点，而且每一种都有有用的性质。
### 深度优先遍历

  在深度优先级中，我们希望从根结点访问最远的结点。和图的深度优先搜索不同的是，不需记住访问过的每一个结点，因为树中不会有环。前序，中序和后序遍历都是深度优先遍历的特例。
#### 前（先）序、中序、后序遍历
遍历二叉树：L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则**先(根)序**遍历二叉树的顺序是DLR，**中(根)序**遍历二叉树的顺序是LDR，**后(根)序**遍历二叉树的顺序是LRD。还有按层遍历二叉树（先上后下，先左后右）。这些方法的时间复杂度都是O(n)，n为结点个数。
（无论是哪种遍历方法，都遵循先左后右）

# 线索二叉树

**当对一个完全二叉树进行遍历时，发现其叶子结点的指针域始终为空，浪费了空间资源，于是我们希望充分利用各个结点的左右指针，让各个结点可以指向自己的前后结点，这就是线索化二叉树。**

在线索二叉树中，一个结点的左孩右孩不存在时，对应的线索指针才指向其前驱或后继。

n 个节点的二叉树链表中含有 `n + 1` 个空指针域，他的推导公式为 `2n-(n-1) = n + 1`。
利用二叉链表中的空指针域，存放指向该节点在 **某种遍历次序 **下的 **前驱** 和 **后继** 节点的指针，这种附加的指针称为**「线索」**

如下图，在中序遍历中，下图的中序遍历为 `8,3,10,1,14,6`，那么 8 的后继节点就为 3，3 的后继节点是 10

![image-20201202225302702](https://zq99299.github.io/dsalg-tutorial/assets/img/image-20201202225302702.8c95a6d4.png)

这种加上了线索的二叉树链表称为 **线索链表**（节点存储了下一个节点，组成了链表，并且一般的二叉树本来就是用链表实现的），相应的二叉树称为 **线索二叉树（Threaded BinaryTree）**。根据线索性质的不同，线索二叉树可分为：前、中、后序线索二叉树。



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk2ODEwMzI4NCwxNzkxNTMxMzkzLC03Mj
IzODk2OTYsMTM1ODg3MTkxMCwtMjMzMTA0MDcyXX0=
-->