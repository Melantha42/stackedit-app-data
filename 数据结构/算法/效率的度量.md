

# 算法效率
## 时间复杂度
事先预估算法的**时间开销T（n）**与**问题规模n**的关系
通常来说，当算法运行的问题足够大（n→$\infty$ ）时，时间复杂度遵守
- 加法规则：
 T（n）=T$_1$（n）＋T$_2$（n）=O（f(n)）＋O（g(n)）=O（max(f(n),g(n))）
【即：多项相加，只保留最高阶项，且系数变为1（高阶无穷）】
- 乘法规则：
T（n）=T$_1$（n）$×$T$_2$（n）=O（f(n)）×O（g(n)）=O（f(n)×g(n)）

>时间复杂度比较
>**O（1）<O（log$_2$n）<O（n）<O（nlog$_2$n）<O（n$^2$）<O（n$^3$）<O（2$^n$）<O（n！）<O（n$^n$）**

## 如何计算时间复杂度
- 顺序执行的代码只会影响常数项，一般情况可以忽略
如：int main(void)
{
①int i;
②int n;
③while(i<=n){
i++;
p
⑤printf（“%n”,i）;
⑥return 0;
}
语句**频度**：
①，②，③——1次
④——3000次
若输入n=3000
则此代码的时间复杂度T（3000）=


## 空间复杂度

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTY5NjYwMjY3NywxMTkzMzk0MDgyLC05OD
YwNTE4MjFdfQ==
-->