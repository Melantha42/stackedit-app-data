


# 分块查找
也称索引顺序查找，算法思想如下：
①在索引表中确定待查记录所属的分块（可顺序、可折半）
②在块内顺序查找
![输入图片说明](/imgs/2025-07-09/kkycPYakGnsw0Lim.jpeg)

**分块查找**又称**索引顺序查找，**它是**顺序查找**的一种改进方法**。**

　　****算法流程：****

-   先选取**各块**中的**最大关键字**构成一个**索引表**；
-   查找分两个部分：先对索引表进行**二分查找**或**顺序查找**，以**确定待查记录**在**哪一块**中；然后，在已确定的块中用**顺序法**进行查找。

![](https://img2018.cnblogs.com/blog/1731440/201908/1731440-20190821204742418-1840536480.png)

　　**注**：算法的思想是将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"，每个块内的的最大元素**小于**下一块所有元素的**任意一个值**。

　　所以，给定一个**待查找**的**key**，在查找这个**key值**位置时**，**会先去**索引表**中利用**顺序查找**或者**二分查找**来找出这个**key**所在块的**索引**开始位置，然后再根据**所在块的索引开始位置**开始查找这个key所在的**具体位置。**

　　下面给出一段**分块查找**的代码，其思想和上面描述的一样，都是通过**索引表**来找key的位置。

　　先给出**主表**和**索引表**：

![复制代码](https://assets.cnblogs.com/images/copycode.gif)

 1     // 主表，size=30
 2     static int[] mainList = new int[]{
 3             101, 102, 103, 104, 105, 0, 0, 0, 0, 0,
 4             201, 202, 203, 204, 0, 0, 0, 0, 0, 0,
 5             301, 302, 303, 0, 0, 0, 0, 0, 0, 0
 6     };
 7 
 8     // 索引表
 9     static IndexItem[] indexItemList = new IndexItem[]{
10             new IndexItem(1, 0, 5),
11             new IndexItem(2, 10, 4),
12             new IndexItem(3, 20, 3)
13     };

![复制代码](https://assets.cnblogs.com/images/copycode.gif)

　　索引表类：

![复制代码](https://assets.cnblogs.com/images/copycode.gif)

    static class IndexItem {
        public int index; //值比较的索引
        public int start; //开始位置
        public int length;//块元素长度(非空)

        public IndexItem(int index, int start, int length) {
            this.index = index;
            this.start = start;
            this.length = length;
        }

        //... getter and setter
    }

![复制代码](https://assets.cnblogs.com/images/copycode.gif)

　　**索引查找**算法：

![复制代码](https://assets.cnblogs.com/images/copycode.gif)

 1     public static int indexSearch(int key) { 2         IndexItem indexItem = null;
 3 
 4         //建立索引规则
 5         int index = key / 100;
 6 
 7         //遍历索引表
 8         for(int i = 0;i < indexItemList.length; i++) {
 9             //找到索引项
10             if(indexItemList[i].index == index) {
11                 indexItem = indexItemList[i];
12                 break;
13 }
14 }
15 
16         //索引表中不存在该索引项
17         if(indexItem == null)
18             return -1;
19 
20         //根据索引项，在主表中查找
21         for(int i = indexItem.start; i < indexItem.start + indexItem.length; i++) {
22             if(mainList[i] == key)
23                 return i;
24 }
25 
26         return -1;
27     }

![复制代码](https://assets.cnblogs.com/images/copycode.gif)

　　**时间复杂度**分析：先按**二分查找**去找key在**索引表**为大概位置（所给出代码是顺序查找），然后**在主表**中的可能**所在块**的位置开始按顺序查找，所以时间复杂度为**O(log₂(m)+N/m)**，m为分块的数量，N为主表元素的数量，N/m 就是每块内元素的数量。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTYzNTIwNTQyOCwtMTY1NDg0MDczOSw4Nz
Q2MzQ0NzZdfQ==
-->