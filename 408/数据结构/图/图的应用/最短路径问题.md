


# 最短路径问题
##  单源最短路劲
### BFS算法（无权图）
在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为**最短路径问题**。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。

在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。

PS：BFS算法只适用于无权图。

### 迪杰斯科拉（Dijkstra）算法（带权图、无权图）

是BFS算法的升级版，用于处理带权图的最短路径问题，通过构造三个数组分别表示顶点（访问与否）、最短路径长度（结合该路径的前驱）、路径前驱标记。

详细步骤如下：
设一数组
①构建上述数组，令所有final[]值为假
②进行第一轮遍历：遍历所有结点，找到未确定最短路径，且最短路径长度最小的顶点，最后令该顶点值为真。
![输入图片说明](/imgs/2025-07-07/eNRQMWJ3aGO2LW5k.jpeg)
③检查所有邻接于“②”步骤的顶点，若其final值为假，则更新最短路径长度和前驱数组的信息。
④重复“②”“③”步骤，直到所有最短路径确定



## 各顶点间的最短路径

### Floyd算法（带权图、无权图）
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExMjE4Mzk0NDAsLTEyODEzODExNDYsLT
k2NzE0OTM1MywxMTU1NzYyNDI1LDQ0MDkwNTYxOV19
-->