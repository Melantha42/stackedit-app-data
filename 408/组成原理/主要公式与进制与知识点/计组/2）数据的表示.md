

# 重要考点
- 数据无后缀或后缀为D表示十进制，H表十六进制，B表二进制

- 在C语言中int类型的数据采用二进制补码表示。

- 正数的补码是其本身，负数的补码除符号位外全部按位取反后+1.
- 将short型变量进行强制类型转换int后，符号高位进行零扩展（高位补零）
- IEEE.745中，阶码的表示：阶码采用移码表示，当8bit移码的最高位为1时，说明移码减去偏移量127为正数（对于FLOAT单精度浮点型变量），**此时阶码的真值为移码（除去最高位）＋1**（移码-偏置量=移码的真值）偏置量=2$^n$-1,此处n为8。
- IEEE.745的单精度标准规格化浮点数表示中，表示小数点的23bit是从23位开始按位加2$^i$（i=-1,-2,-3...-23），小数部分真值前默认是1。
- 大小端存储方式：在计算机系统中，大端（Big-Endian）和小端（Little-Endian）存储方式是两种不同的数据表示方法。这两种方式定义了多字节数据在内存中如何排列。大端存储方式（Big-Endian）在大端模式下，**数据的高字节**（即最重要的部分）保存在**内存的低地址**中，而数据的低字节（即最不重要的部分）保存在内存的高地址中。例如，假设我们有一个十六进制数_0x12345678_，在大端模式下，_0x12_是高字节，将被存储在最低的地址，随后是_0x34_，然后是_0x56_，最后是_0x78_存储在最高的地址。小端则相反。

- **补码一位乘法**：N位操作数的乘法操作是将操作数进行N轮加法、位移运算，最后再加上1次加法操作，最多需要N+1次加法操作和N次位移操作。PS：N是去掉符号后剩下的位数。
- **补码除法**：加减法次数：N+1；移位次数：N；
- **原码一位乘法**：加减法次数：N；移位次数：N；
- **原码除法**：加减法次数：N+1或N+2；移位次数：N；


- **溢出判断**：符号位判断法——正＋正=负/负＋负=正（OF标志位判断）
- **无符号数溢出判断**：看CF是否进位jia
- **符号标志位**：CF是进位标志，指示最近的操作是否有进位或借位（最高位），当最高位加法有进位或减法有借位时，其显示1；OF是溢出标志，表示有符号数运算结果是否超出表示范围，其显示1则表示溢出；ZF是零标志，表示运算结果是否为零，显示1则表示上一条操作结果为0；SF是符号标志，指示运算结果是否为负数，其显示1表示最高位是1，该数为负数。

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1Njg2NTU1NTQsMTY4MTQxMzM1NCwtMz
M4MTQ3NTAxLC03NDM4NzczMiwtOTQxNDA4MDU2LDQxMzQyNjgy
MiwtMTUwOTM1MTkzMywxNjE2MDY5MTEzLC0xNjU3NzkwNzc1LD
c1MjIxODcxOF19
-->