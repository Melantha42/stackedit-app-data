


好的，我们来系统地总结一下408操作系统第二章中关于**死锁**的核心考点。

死锁是进程管理中的重点和难点，通常围绕**定义、条件、处理策略**三个方面展开。

---

### 一、 死锁的定义

**死锁**是指在一组进程中的各个进程均**无限期地等待**永远不会发生的条件，从而导致所有进程都无法继续向前推进的现象。

**通俗理解**：多个进程互相“占着茅坑不拉屎”，同时又想得到对方占着的“茅坑”，结果谁都进行不下去，形成了一种僵局。

---

### 二、 死锁产生的四个必要条件

这四个条件是Coffman总结的，**必须同时满足**才会发生死锁。

1.  **互斥条件**：资源在任意时刻只能被一个进程使用。
2.  **不剥夺条件**：进程已获得的资源，在未使用完之前，不能被其他进程强行夺走，只能由该进程主动释放。
3.  **请求和保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
4.  **循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。

> **关键点**：这是死锁的**必要条件**，但不是充分条件。也就是说，发生死锁一定有这四个条件，但满足这四个条件不一定立刻发生死锁。

---

### 三、 死锁的处理策略

主要有三种策略：

#### 1. 死锁预防

**核心思想**：**破坏**死锁产生的四个必要条件中的一个或几个，使其无法发生。这是一种**静态**的、严格的策略。

*   **破坏互斥条件**：将独占资源改造成可共享资源（如只读文件）。但很多资源本质是无法共享的（如打印机），因此这种方法实用性有限。
*   **破坏不剥夺条件**：当一个进程请求的资源得不到满足时，它必须释放已经持有的所有资源，待以后需要时再重新申请。实现复杂，代价高。
*   **破坏请求和保持条件**：采用**静态分配法**。进程在运行前一次性申请其所需全部资源，在资源未满足前不投入运行。一旦运行，这些资源就一直归它所有。**简单易行，但资源利用率极低，可能导致“饥饿”。**
*   **破坏循环等待条件**：采用**顺序资源分配法**。给所有资源类型编号，规定每个进程必须**按编号递增的顺序申请资源**。**这是最常用的预防方法**，但编号必须合理，否则仍会导致资源利用率下降。

#### 2. 死锁避免

**核心思想**：在资源动态分配过程中，用某种算法（如**银行家算法**）去**判断此次分配是否会导致系统进入不安全状态**，从而决定是否分配。这是一种**动态**的策略。

*   **安全状态**：系统能按某种顺序（如 `<P1, P2, ..., Pn>`）为每个进程分配其所需资源，直至满足每个进程的最大需求，使每个进程都能顺利完成。该序列称为**安全序列**。
*   **不安全状态**：不存在任何一个安全序列。**不安全状态不一定是死锁状态，但死锁状态一定是不安全状态。**

*   **银行家算法**
    *   **数据结构**：
        *   `Available`：可用资源向量。
        *   `Max`：最大需求矩阵。
        *   `Allocation`：分配矩阵。
        *   `Need`：需求矩阵（`Need = Max - Allocation`）。
    *   **步骤**：
        1.  当进程提出资源请求 `Request_i` 时，先检查是否 `Request_i <= Need_i`，否则报错。
        2.  检查是否 `Request_i <= Available`，否则表示资源不足，进程等待。
        3.  系统**试探性**地分配资源，修改状态：
            *   `Available = Available - Request_i`
            *   `Allocation_i = Allocation_i + Request_i`
            *   `Need_i = Need_i - Request_i`
        4.  调用**安全性算法**，检查系统是否仍处于安全状态。
        5.  若安全，才正式分配；否则，撤销试探分配，让进程等待。

#### 3. 死锁的检测与解除

这种策略允许死锁发生，但系统会负责检测并修复。

*   **死锁检测**
    *   **资源分配图**：用有向图描述系统状态。
        *   顶点：进程集合 P + 资源集合 R。
        *   边：申请边（P → R，进程申请资源）、分配边（R → P，资源已分配给进程）。
    *   **死锁定理**：通过**简化资源分配图**来检测是否存在死锁。
        *   简化方法：找一个**既不阻塞又孤立的进程**（即它申请的资源都能满足），消去它所有的请求边和分配边。重复此过程。
        *   若最终所有顶点都被消去，则图是可完全简化的，**没有死锁**。
        *   若最终无法完全简化，则**不可简化的部分**就是死锁进程。

*   **死锁解除**
    一旦检测到死锁，就需要采取措施打破僵局。
    1.  **资源剥夺法**：挂起某些死锁进程，抢占其资源分配给其他进程。但需要考虑如何防止被挂起进程“饿死”。
    2.  **撤销进程法**（终止进程法）：强制撤销一个或多个死锁进程，并剥夺它们的资源。可以全部撤销，也可以按某种顺序逐个撤销，直到死锁解除。
    3.  **进程回退法**：让一个或多个进程回退到足以避免死锁的地步。要求系统记录进程的历史信息，设置还原点。

---

### 四、 总结与对比

| 策略 | 核心思想 | 主要方法 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- | :--- |
| **死锁预防** | 破坏必要条件，**不让死锁发生** | 静态分配、顺序分配 | 简单、开销小 | 资源利用率低，限制进程并发 |
| **死锁避免** | 动态检查，**避免进入不安全状态** | 银行家算法 | 资源利用率较高 | 算法开销大，要求事先知道最大需求 |
| **死锁检测与解除** | **允许死锁发生**，再处理 | 资源分配图简化、撤销进程 | 资源利用率最高，并发度高 | 解除死锁的代价大，可能造成损失 |

**备考重点**：
1.  深刻理解并熟记**死锁的四个必要条件**。
2.  掌握三种处理策略的核心思想及其典型方法（特别是**银行家算法**和**资源分配图简化**）。
3.  能够判断给定系统状态是否安全，或给定资源分配图是否存在死锁。
4.  能够比较三种策略的优缺点和适用场景。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjA3NzU3Mjc3XX0=
-->