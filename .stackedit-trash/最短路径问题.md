


# 最短路径问题
##  单源最短路劲
### BFS算法（无权图）
在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为**最短路径问题**。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。

在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。

PS：BFS算法只适用于无权图。

### 迪杰斯科拉（Dijkstra）算法（带权图、无权图）

是BFS算法的升级版，用于处理带权图的最短路径问题，通过构造三个数组分别表示顶点（访问与否）、最短路径长度（结合该路径的前驱）、路径前驱标记。

**详细步骤如下**：
设一数组final表示顶点是否找到最短路径
①构建上述数组，令所有final[]值为假、初始顶点路径值为-1。
②进行第一轮遍历：遍历所有结点，找到未确定最短路径，且最短路径长度最小的顶点，最后令该顶点值为真。
![输入图片说明](/imgs/2025-07-07/eNRQMWJ3aGO2LW5k.jpeg)
③检查所有邻接于“②”步骤的顶点，若其final值为假，则更新最短路径长度和前驱数组的信息。
[图片上传中...(image-VizaCyllRXtUrp32)]
④重复“②”“③”步骤，直到所有最短路径确定
![输入图片说明](/imgs/2025-07-07/0oWIOn42XRO3HRtT.jpeg)

- Dijkstra 时间复杂度 O（V$^2$）:
| .遍历顶点数组：O(V)
|| . for循环V-1次处理
| × || = O(V$^2$)
![输入图片说明](/imgs/2025-07-07/pSJspvUiQljXUxkh.jpeg)
#### 负权值带权图与dijkstra
![输入图片说明](/imgs/2025-07-07/S9UFKOfVy39FO2Lt.jpeg)
当带权图中出现负权值路径，且该路径遍历轮次在另一正值路径之后，则会出现非最短路径长度，因此，**Dijkstra算法不适应于含有负权值路径的带权图**

## 各顶点间的最短路径

### Floyd算法（带权图、无权图）
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzgwODUzNzMxXX0=
-->